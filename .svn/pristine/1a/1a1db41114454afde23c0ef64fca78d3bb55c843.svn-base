<?xml version="1.0" encoding="utf-8"?>
<articles>
  <article>
    <author>Thomas Cormen</author>
    <title>Algorithms</title>
    <year>2013</year>
    <month>11</month>
    <day>1</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\IntrAlgPic.jpg</image>
    <category>Introduction to Algorithms 3rd Edition</category>
    <description>The Role of Algorithms in Computing</description>
    <contents>Informally, an algorithm is any well-defined computational procedure that takes
some value, or set of values, as input and produces some value, or set of values, as
output. An algorithm is thus a sequence of computational steps that transform the
input into the output.
We can also view an algorithm as a tool for solving a well-specified computational
problem. The statement of the problem specifies in general terms the desired
input/output relationship. The algorithm describes a specific computational procedure
for achieving that input/output relationship.
For example, we might need to sort a sequence of numbers into nondecreasing
order. This problem arises frequently in practice and provides fertile ground for
introducing many standard design techniques and analysis tools. Here is how we
formally define the sorting problem:
Input: A sequence of n numbers ha1; a2; : : : ;ani.
Output: A permutation (reordering) ha0

For example, given the input sequence h31; 41; 59; 26; 41; 58i, a sorting algorithm
returns as output the sequence h26; 31; 41; 41; 58; 59i. Such an input sequence is
called an instance of the sorting problem. In general, an instance of a problem
consists of the input (satisfying whatever constraints are imposed in the problem
statement) needed to compute a solution to the problem
Because many programs use it as an intermediate step, sorting is a fundamental
operation in computer science. As a result, we have a large number of good sorting
algorithms at our disposal. Which algorithm is best for a given application depends
on—among other factors—the number of items to be sorted, the extent to which
the items are already somewhat sorted, possible restrictions on the item values,
the architecture of the computer, and the kind of storage devices to be used: main
memory, disks, or even tapes.
An algorithm is said to be correct if, for every input instance, it halts with the
correct output. We say that a correct algorithm solves the given computational
problem. An incorrect algorithm might not halt at all on some input instances, or it
might halt with an incorrect answer. Contrary to what you might expect, incorrect
algorithms can sometimes be useful, if we can control their error rate. We shall see
an example of an algorithm with a controllable error rate in Chapter 31 when we
study algorithms for finding large prime numbers. Ordinarily, however, we shall
be concerned only with correct algorithms.
An algorithm can be specified in English, as a computer program, or even as
a hardware design. The only requirement is that the specification must provide a
precise description of the computational procedure to be followed.</contents>
  </article>
  <article>
    <author>Thomas Cormen</author>
    <title>Stacks and queues</title>
    <year>2013</year>
    <month>12</month>
    <day>1</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\IntrAlgPic.jpg</image>
    <category>Introduction to Algorithms 3rd Edition</category>
    <description>Elementary Data Structures</description>
    <contents>Stacks and queues are dynamic sets in which the element removed from the set
by the DELETE operation is prespecified. In a stack, the element deleted from
the set is the one most recently inserted: the stack implements a last-in, first-out,
or LIFO, policy. Similarly, in a queue, the element deleted is always the one that
has been in the set for the longest time: the queue implements a first-in, first-out,
or FIFO, policy. There are several efficient ways to implement stacks and queues
on a computer. In this section we show how to use a simple array to implement
each.
Stacks
The INSERT operation on a stack is often called PUSH, and the DELETE operation,
which does not take an element argument, is often called POP. These names
are allusions to physical stacks, such as the spring-loaded stacks of plates used
in cafeterias. The order in which plates are popped from the stack is the reverse
of the order in which they were pushed onto the stack, since only the top plate is
accessible.</contents>
  </article>
  <article>
    <author>Thomas Cormen</author>
    <title>Linked lists</title>
    <year>2013</year>
    <month>12</month>
    <day>5</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\IntrAlgPic.jpg</image>
    <category>Introduction to Algorithms 3rd Edition</category>
    <description>Elementary Data Structures</description>
    <contents>A linked list is a data structure in which the objects are arranged in a linear order.
Unlike an array, however, in which the linear order is determined by the array
indices, the order in a linked list is determined by a pointer in each object. Linked
lists provide a simple, flexible representation for dynamic sets, supporting (though
not necessarily efficiently) all the operations listed on page 230.</contents>
  </article>
  <article>
    <author>Brian Switek</author>
    <title>Newfound Giant Dinosaur Ruled Before T. Rex</title>
    <year>2013</year>
    <month>11</month>
    <day>23</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\NGPic.png</image>
    <category>National Geographic</category>
    <description>National Geographic</description>
    <contents>Tyrannosaurs reign as the most famous of all meat-eating dinosaurs. But they didn't always dominate, suggests the newly discovered bones of a massive carnivorous dinosaur that lived 98 million years ago.
Named Siats meekerorum (pronounced "See-atch"), the dinosaur discovered in eastern Utah by paleontologists was a previously unknown "apex," or top, predator that ruled long before North America's tyrannosaurs came to power. (See also: "Smallest Meat-Eating Dinosaur Discovered in North America.")
In the Nature Communications study published today, Lindsay Zanno of North Carolina State University and Peter Makovicky of Chicago's Field Museum of Natural History add to our knowledge of gigantic dinosaur predators prior to the days of Tyrannosaurus rex, which lived some 67 million years ago.
At full size, the two-legged carnivore may have weighed more than four tons and stretched nearly the length of a school bus.
The discoverers report that the dinosaur's first (or genus) name is a tribute to its predatory prowess. In the legends of Utah's native Ute tribe, "Siats" is the name of a voracious monster.
Black Bone Discovery
Zanno knew she had discovered a significant dinosaur as soon as she happened across a collection of black bone fragments sitting on the surface of eastern Utah's Cedar Mountain Formation.
Remains of large carnivorous dinosaurs are rare in these rocks. "We had no idea how much would be in the ground," Zanno says, "but we were stoked because we knew immediately we had a larger theropod and that it was going to fill in a huge gap in our understanding of theropod evolution on the continent."
The discovery team recovered a partial skeleton including vertebrae, parts of the hip, the lower leg, and toes.
At first, Zanno says, she expected that Siats would be something like the huge, sail-backed carnivore Acrocanthosaurus, but the new dinosaur turned out to be something else. Distinctive anatomic features on the bones mark Siats as a newly recognized type of predator called a neovenatorid, cousins of the earlier, well-known Allosaurus.
Similar to a previously discovered dinosaur called Neovenator, Siats would have sported a pointier, less blocky head than the big tyrannosaurs, and had relatively long, three-clawed arms, rather than short ones like those made famous by T. rex.
Incomplete Skeleton
Since the newly discovered dinosaur's known skeleton is incomplete and is from a juvenile, Siats' exact size at adulthood isn't entirely clear.
From estimates based on comparisons with more complete skeletons of other dinosaurs, Zanno says that "a juvenile Siats would have been, at minimum, about 30 feet long and around 9,000 pounds."
That's an impressive size that "still puts juvenile Siats as the third largest predator ever discovered in North America," Zanno says. The fact that the animal was not yet fully mature raises the likelihood that the adults were even bigger.
"Future material may reveal Siats grew up to be one of the biggest predators known around the globe," Zanno says.
Keeping Tyrannosaurs Down
The size of Siats is only part of the dinosaur's significance. "In the rock beds that contain the colossal bones of Siats, we also find the teeth of relatively tiny tyrannosaurs about the size of a large dog," Zanno says.
Early tyrannosaurs lived in the shadow of gigantic allosaurid carnivores like Siats. It was only after dinosaurs such as Siats disappeared, Zanno says, "that tyrannosaurs were free to evolve into the giant predators we know and love today."
University of Oxford paleontologist Roger Benson, who first recognized neovenatorids with colleagues in a 2010 study, agrees that Siats helps fill in a missing chapter in predatory dinosaur history.
Until now, there were "25 million years of missing data," Benson says, between allosaurid giants like Acrocanthosaurus and North America's huge tyrannosaurs.
With Siats at 98 million years old, he adds, the dinosaur "shows us that allosaurids stayed on top for at least another 10 million years." Exactly when and why dinosaurs like Siats gave way to the tyrannosaurs, however, relies on future Cretaceous finds from this final era of the Age of Dinosaurs.</contents>
  </article>
  <article>
    <author>Dan Vergano</author>
    <title>New Clues About Human Sacrifices at Ancient Peruvian Temple</title>
    <year>2013</year>
    <month>11</month>
    <day>19</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\NGPic.png</image>
    <category>National Geographic</category>
    <description>National Geographic</description>
    <contents>Human-sacrifice rituals at an ancient Moche temple in Peru likely featured the killing of war captives from distant valleys, according to an analysis of bones and teeth at the site.

The human remains—mutilated, dismembered, and buried in pits—help explain territorial struggles among the Moche, who ruled Peru's arid coast from around 100 A.D. to 850 A.D. (See also "Moche Burials Uncovered.")

Debate among scholars over Moche human sacrifices has centered on the question of whether they were ritual killings of elites or of war prisoners, says archaeologist John Verano of Tulane University in New Orleans, one of the authors of the report, available online and in an upcoming issue of Journal of Archaeological Science.

"They look like war captives," Verano concludes, pointing to the study's bone chemistry results, which suggest that sacrifice victims came from far away in the late days of the Moche empire.

Appeasing the Gods

The Moche left behind distinctive pottery, irrigation works, and giant adobe mounds, some adorned with murals depicting war captives.

Among the largest-known Moche ruins is the brick mound site of Huacas de Moche, located near the modern-day city of Trujillo, Peru. The mound consists of three platforms connected by corridors, plazas, and temples.

Roughly 70 sacrifice victims have been found there so far—an indication of frequent human offerings. That alone suggests the slaughter of captured warriors rather than rare killings of elites to appease the gods in religious rituals, Verano says. The victims were killed, displayed, and later swept into pits.

"You don't deny a proper burial, deflesh, mutilate, and turn your elites' bones into trophies as they did [at Huacas de Moche]," says Verano, whose work has been partly supported by National Geographic Society grants. "You don't make a drinking mug out of your elite [ruler's] skull."

Sacrifice ceremonies are depicted in Moche artwork, often showing the killing of bound, naked men. Priests and priestesses are portrayed offering goblets filled with the victims' blood to supernatural beings.

The sacrifice victims' bones were then left for vultures.

Victims From Far Away

The new report is the result of work on the remains of 34 people, some buried in neatly ordered graves and others in burial pits, the latter including young men with their throats slit and bones dismembered.

The chief author of the report, J. Marla Toyne of the University of Central Florida in Orlando, led efforts to analyze oxygen isotopes in the remains of the dead.

The water that people drink leaves specific oxygen traces in bones and teeth, which can help determine where victims lived, both in infancy and in the last decade of their lives. In the case of the Huaca de Moche burials, the male elite—buried in neat graves—were all locals who drank the local river water.

A Long-Term Shift

In the heyday of Huacas de Moche, around 600 A.D., perhaps 25,000 people lived there. Two large temples, the Huaca de la Luna (Temple of the Moon) and the Huaca del Sol (Temple of the Sun), sat atop the mound.

"Who you are choosing to kill, who you are choosing to sacrifice, says a lot about how you see other people," Toyne says. "We are seeing a long-term shift in the origins of sacrifice victims to farther and farther away."


For the past two decades, archaeologists have suspected that some Moche states pursued empire-building along the Andean coast, says Peruvian Ministry of Culture archaeologist Luis Jaime Castillo Butters, who was not part of the study team.

"The Southern Moche, based in the Huacas de Moche, seem to have been the truly expansionist ones," he wrote by email. "Marla Toyne's research proves this with isotopic information."

Game of Thrones

When Huacas de Moche was first discovered 50 years ago, archaeologists thought that it was the capital of a long-standing Moche empire rather than a city that had expanded its geographic dominance over time.

The new study suggests that Moche centers vied with each other for power and resources, which likely led to warfare. The battles led to the taking of captives, and it seems that captives were slain in sacrifice ceremonies.

Another intriguing result of the bone analysis is that elite women buried at the temples also appear to have largely come from elsewhere.

That points to a "patrilocal" system for the Moche, suggesting that they traded "princess brides" between centers, Verano says. "Not so different from now in some places."

Overall, the findings are updating the view of the enigmatic Moche, who didn't leave behind records as detailed as those of contemporaries such as the Maya of Central America.

"We have to do a lot of careful detective work, still," says Verano, who has been part of excavation work at Huaca de Moches for more than a decade.</contents>
  </article>
  <article>
    <author>Andrew Fazekas</author>
    <title>6 Sky Events This Week: Dawn Planets, Lunar Encounters, and Celestial Hunter</title>
    <year>2013</year>
    <month>11</month>
    <day>25</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\NGPic.png</image>
    <category>Space</category>
    <description>National Geographic</description>
    <contents>As we head toward the final days of November, skywatchers spy pretty planetary and lunar pairings and a mythical hunter, while anxiously waiting to learn of the fate of comet ISON as it rounds the sun.

Moon and Regulus. In the hours before sunrise on Tuesday, November 26, look for the last quarter moon to fill the southeast sky. Perched to its upper right is the bright blue-white star Regulus, the brightest member of the constellation Leo (the lion).

Despite being 78 light years away, Regulus ranks as the 21st brightest star in the entire sky.  A true stellar giant, it weighs in with about four times the mass of our sun and has surface temperatures that are roughly double, which means it is burning its gas fuel at a fast and furious pace.

So while its estimated age is only a few hundred million years old, it is probably already becoming elderly and will likely die before it reaches a billion years in age. That may sound like an incredibly long time, but compare it to our own sun’s lifetime, which is estimated to be as much as 10 billion years long.

Mercury and Saturn. As dawn approaches on Tuesday, November 26, you can glimpse two naked-eye planets, Mercury and Saturn very low in the southeast sky from around the globe.

The pair of worlds will appear separated by only one degree, equal to the width of two full moons side by side in the sky.  Easily fitting into the view of binoculars and telescopes, Mercury will appear hanging below the brighter Saturn.

And that faint little star to the planetary pair’s upper right? That is 77 light-year distant Zubernelgenubi, the lead star in the zodiacal constellation Libra (the scales). It’s name is derived from Arabic meaning the “southern claw of the scorpion,” referring to ancient Babylonian times when astronomers considered this star part of the Scorpius constellation.

Moon and Mars. In the early morning hours of Wednesday, November 27, the waning crescent moon forms a stunning pair with the ruddy colored Mars. The celestial duo will appear only about five degrees apart, equal to the span of your three middle fingers at arm’s length.

It’s kind of amazing to think that this orange point of light is actually another world some 254 million kilometers away, and that both NASA and India have orbiters now heading towards the red planet.

ISON Perihelion.  On Thursday, November 28, comet ISON makes it closest approach to the sun (perihelion). While skywatchers wait anxiously to see if the icy visitor survives its scorching encounter—passing less than 1.1 million kilometers above the sun’s surface—NASA’s solar probes are watching all the action from space.  So while the next few days Comet ISON is too close to the glare of the sun to see, STEREO-A spacecraft is continually monitoring it along with Earth, Mercury, and even Comet Encke.

Moon and Planet Line-up. Set your alarms early for Sunday, December 1, when the razor-thin crescent moon appears sandwiched in between Mercury and Saturn. The dawn sky show will play out in the very low southeast and is best seen from a vantage point that has no obstruction towards the horizon.

Winter Orion Rises. By mid-evening on Sunday, December 1, look towards the southeast sky for the winter season’s most celebrated constellation—Orion, the hunter. It’s stellar pattern is one of the easiest to recognize for novice skywatchers thanks to the perfect alignment of three equally bright stars in a row, which marks the belt of Orion. Meanwhile, to the upper left of the belt, is the bright orange star Betelgeuse, which marks the left shoulder of the legendary hunter.  Rigel marks the right knee of the stellar character below right of the trio.</contents>
  </article>
  <article>
    <author>Lisa Winter</author>
    <title>The Most Extreme Weather In the Solar System</title>
    <year>2013</year>
    <month>11</month>
    <day>11</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\NGPic.png</image>
    <category>Space</category>
    <description>Space</description>
    <contents>“Fly me to the moon, let me play among the stars. Let me see what spring is like on Jupiter and Mars…” 

Spoiler alert: the weather Earth is far nicer than on any other planet in our solar system. Sure, you might have to carry an umbrella sometimes and the bottoms of your pants get all wet, and the wind kicks around pollen which can cause pesky allergies. But then you don't have to worry about sulfuric acid falling out of the sky, which is nice.
Our Solar System is home to some fairly extreme weather. Here's our picks.

Mercury
Mercury almost completely lacks an atmosphere, but that doesn’t mean that it doesn’t have extreme physical conditions. As the closest planet to the sun it's no surprise that the temperature of the planet can get extremely hot - but the lack of atmosphere means that it is unable to retain the heat and can therefore can have incredible temperature swings.
In addition to barely having an atmosphere, Mercury doesn't have much in the way of axial tilt. Because of this, there are no seasonal changes in weather. It also rotates incredibly slowly, as it only has about three “days” every two years. When Mercury is closest to the sun, the surface temperature can reach over 800º F (approx 430º C). During the night temperatures can dip down to -290º  F (-180º  C). 
If a human were to visit Mercury, he or she would either burst into flames or freeze solid depending on where the spaceship landed.

Venus
Our neighbor Venus is essentially the poster child for how greenhouse gasses can create a completely hellish environment. With a super-thick atmosphere of mostly carbon dioxide, Venus is able to trap more of the sun’s radiation than Mercury which allows it to reach (and retain) much higher temperatures. The surface temperature stays relatively consistent all year at 900º  F (480º  C). The pressure on Venus is approximately 90 times higher than sea level on Earth. In order to recreate that pressure here, a diver would need to venture 1000 meters down into the ocean. 
Rain on Venus is almost purely sulfuric acid, which is extremely corrosive. Sulfuric acid can erode clothing nearly instantly and produce severe burns on flesh. However, the surface temperature of Venus is so great, the rain evaporates before hitting the ground. There is a little water in the atmosphere, which can produce violent explosions when it meets the sulfuric acid. Though Venus is only slightly smaller than Earth, it takes only four hours for the atmosphere to completely rotate around the planet. Here, it it takes about 243 days to accomplish the same task.
Even with these extremely high temperatures, there is snow on Venus. Well, not snow as we know it. It's a basalt frost remnant of metals that vaporized in the atmosphere.
Forget what would happen if a human were to visit Venus; we haven’t even sent probes that lasted longer than a couple hours on the surface due to the intense conditions.

Mars
Mars is currently under a lot of investigation as some believe it may have harbored life in the past and could give clues to the origin of life on Earth. Because it once was home to flowing water, there must have been an atmosphere capable of holding it there. Now the surface is dry and huge cyclones of dust can tear apart the landscape. 
Mars’ missing atmosphere is a mystery but there is still plenty of bizarre weather happening on the planet. The poles are covered in ice caps and there are intense snowstorms. While our snow is made of frozen water, Martian snow is actually made from frozen carbon dioxide, which we know as “dry ice.”
Like Mercury, Mars’ super-thin atmosphere has a hard time holding in heat from the sun. Temperatures at the equator can be a comfortable 70º  F. (20º  C) in the sun, but at night the same spot can dip to -58º  F (-50º  C).
Massive dust storms can take over Mars quite easily. While dust devils happen on Earth in dry areas, the ones on Mars can envelop the entire planet over the course of a few days. 
As for what it might look like for a human to visit Mars, we might not have to wait too much longer. It is hoped that plans to send the first astronauts will set foot on Mars within the next few decades.

Jupiter
It doesn’t take a particularly large telescope to see that Jupiter has a lot of gigantic storms. The most famous of these storms is known as the Great Red Spot (GRS), which has been raging on like a hurricane for at least 400 years. This storm is so massive, three Earths could fit inside it easily. There is another spot known as the Oval BA which was discovered about seven years ago which is now moving as fast as its larger counterpart, and even appears to be increasing in size.
The stripes on Jupiter are caused by jet streams. Jet streams on Earth vary, though we usually only have 1 or 2 in each hemisphere. Jupiter is home to at least 30 which tear across the planet in opposite directions reaching speeds of over 300 mph (482 km/h). Two of these jet streams are responsible for holding the GRS in its present location. The clouds that appear as stripes are composed of frozen ammonia, as the temperature at that part of the atmosphere is -220 degrees F (-140 degrees C). Earlier this year, it was discovered that Jupiter can form diamonds in its atmosphere. 

Europa
Some of Jupiter’s 67 moons can also have pretty intense weather. The surface of Europa is covered in a 62-mile-deep (100 km) saltwater ocean, which is enclosed in a layer of ice. Europa may even have some of the chemical compounds needed for life, which has many astrobiologists excited.

Io
Io has hundreds volcanoes on its surface which respond to gravitational fluctuations from Jupiter. While these active spots can exceed 3092º  F (1700º  C), other patches of the moon are freezing. Because of the moon’s low gravity, these eruptions can shoot as over 250 miles (402 km) above the surface. Earlier this year, it was discovered that the volcanos aren’t even where they should be, based off of temperature models. 

Saturn
Like Jupiter, Saturn’s atmosphere is composed mostly of hydrogen. Wind speeds can reach as high as 1000 mph (1609  km/h) which is just about as fast as a speeding bullet. The highest wind speed ever recorded on Earth during a hurricane was in 1996, during Tropical Cyclone Cynthia when gusts reached 253 mph (408 km/h). 
At Saturn’s North Pole there is an extremely cool storm going on. It isn’t circular or rounded like most extreme weather systems but it is actually shaped like a hexagon. The clearest image of this storm can be seen in a composite that was released last month. Each side of the hexagon is 8,600 miles (13,800 km) long, which is very close to the diameter of Earth.
Though the atmosphere is very thin and cold there is plenty of heat down towards the surface that can generate some extreme storms. In the northern hemisphere, there is a storm which is 10,000 km across. If that were on Earth, it would be like starting in Los Angeles and traveling due east all the way to Beijing, China.
Toward Saturn’s surface the carbon in air can be pressed into graphite. Yes, Saturn has pencil lead flying around. Even closer to the core the carbon is pressed into diamond. If a human were to travel to Saturn, the diamonds would cut through their body like countless little bullets.

Titan
Titan, Saturn’s largest moon, has huge lakes which initially look promising for a spring break vacation spot. However, the temperature is about -260º  F (-162º  C), and the lakes aren’t made of water - it’s actually liquid methane!

Uranus 
Uranus is the coldest planet in the solar system with temperatures hitting -371º  F (−224º  C). Uranus is quite odd in that it is tipped entirely on its side, with the North Pole facing the sun. This may have been the result of a massive collision, as its magnetic field does not align with its poles. 
At first glance Uranus looks like a plain blue ball with not a lot going on, but the planet has a fairly active weather system and enormous hurricanes that can only be seen with infrared telescopes. Like Jupiter, Uranus also has diamonds raining down on its surface.

Neptune
Our most distant planet, Neptune, is home to extreme weather similar to the other gas giants. While it has storms large enough to swallow the entire Earth and bands of weather that mark the planet’s latitude, it also has the most violent wind in the solar system which can reach an astonishing 1,500 mph (2414 km/h). Because Neptune’s topography is fairly flat, there is no friction to slow down these incredible gusts of wind. Like all of the other gas planets, atmospheric carbon compresses into diamond rain.

Triton
Neptune has over a dozen moons, the largest of which is Triton. This moon has an average temperature of -315 degrees F (-192 degrees C). If you wanted to visit, the trip would have to happen in the next 10-100 million years. Triton is slowly getting closer to Neptune and will most likely be ripped up into a Saturn-like ring system.
A trip to Neptune would also include listening to the sound barrier break as the wind blows, though the visitor would freeze solid almost instantly.

Pluto
Pluto experiences MASSIVE swings in temperature due to its high elliptical orbit. When Pluto is farthest away from the sun it is completely frozen over. As it gets closer to the sun, the gas heats up and it produces a gassy atmosphere, which also hurts its planetary status, as it acts more like a comet. As Neil deGrasse Tyson put it, "If you slid Pluto to where Earth is right now, heat from the sun would evaporate that ice, and it would grow a tail. Now, that's no kind of behavior for a planet.”

Our solar system is home to some pretty extreme weather. Learning about how these systems work can increase our knowledge of how some of these planets were formed and even give clues about the potential for life. But when it comes down to actually spending time on the surface on some of these planets, barring major technological advances, there’s no place like home.
Correction: The saltwater ocean on Europa is 62 miles (100 km) deep, not the layer of ice.

- See more at: http://www.iflscience.com/space/most-extreme-weather-solar-system#sthash.3HjMiNr5.dpuf</contents>
  </article>
  <article>
    <author>Светлин Наков</author>
    <title>Бройни Системи</title>
    <year>2013</year>
    <month>10</month>
    <day>9</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\NakovAlgPic.jpg</image>
    <category>Въведение в програмирането със C#</category>
    <description></description>
    <contents>История в няколко реда
Използването на различни бройни системи е започнало още в дълбока древност. Това твърдение се доказва от обстоятелството, че още в Египет са използвани слънчевите часовници, а техните принципи за измерване на времето ползват бройни системи. По-голямата част от историците смятат древноегипетската цивилизация за първата цивилизация, която е разделила деня на по-малки части. Те постигат това, посредством употре-бата на първите в света слънчеви часовници, които не са нищо друго освен обикновени пръти, забити в земята и ориентирани по дължината и посоката на сянката.
По-късно е изобретен по-съвършен слънчев часовник, който прилича на буквата Т и е градуиран по начин, по който да разделя времето между изгрев и залез слънце на 12 части. Това доказва използването на дванадесетична бройна система в Египет, важността на числото 12 обикновено се свързва и с обстоятелството, че лунните цикли за една година са 12, или с броя на фалангите на пръстите на едната ръка (по три на всеки от четирите пръста, като не се смята палеца).
В днешно време десетичната бройна система е най-разпространената бройна система. Може би това се дължи на улесненията, които тя предо-ставя на човека, когато той брои с помощта на своите пръсти.
Древните цивилизации са разделили денонощието на по-малки части, като за целта са използвали различни бройни системи, дванадесетични и шестдесетични съответно с основи – 12 и 60. Гръцки астрономи като Хипарх са използвали астрономични подходи, които преди това са били използвани и от вавилонците в Месопотамия. Вавилонците извършвали астрономичните изчисления в шестдесетична система, която били насле-дили от шумерите, а те от своя страна са я развили около 2000 г. пр. н. е. Не е известно от какви съображения е избрано точно числото 60 за основа на бройната система, но е важно да се знае че, тази система е много подходяща за представяне на дроби, тъй като числото 60 е най-малкото число, което се дели без остатък съответно на 1, 2, 3, 4, 5, 6, 10, 12, 15, 20 и 30.
Някои приложения на шестдесетичната бройна система
Днес шестдесетичната система все още се използва за измерване на ъгли, географски координати и време. Те все още намират приложение при часовниковия циферблат и сферата на глобуса. Шестдесетичната бройна система е използвана и от Ератостен за разделянето на окръжността на 60 части с цел създаване на една ранна система от географски ширини, съставена от хоризонтални линии, минаващи през известни в миналото места от земята. Един век след Ератостен Хипарх нормирал тези линии, като за целта ги направил успоредни и съобразени с геометрията на
Земята. Той въвежда система от линии на географската дължина, в които включват 360 градуса и съответно минават от север до юг и от полюс до полюс. В книгата "Алмагест" (150 г. от н. е.) Клавдий Птолемей доразвива разработките на Хипарх чрез допълнително разделяне на 360-те градуса на географската ширина и дължина на други по-малки части. Той разделил всеки един от градусите на 60 равни части, като всяка една от тези части в последствие била разделена на нови 60 по-малки части, които също били равни. Така получените при деленето части, били наречени partes minutae primae, или "първа минута" и съответно partes minutae secundae, или "втора минута". Тези части се ползват и днес и се наричат съответно "минути" и "секунди".
Кратко обобщение
Направихме кратка историческа разходка през хилядолетията, от която научаваме, че бройните системи са били създадени, използвани и развивани още по времето на шумерите. От изложените факти става ясно защо денонощието съдържа (само) 24 часа, часът съдържа 60 минути, а минутата 60 секунди. Това се дължи на факта, че древните египтяни са разделили по такъв начин денонощието, като са въвели употребата на дванадесетична бройна система. Разделянето на часовете и минутите на 60 равни части, е следствие от работата на древногръцките астрономи, които извършват изчисленията в шестдесетична бройна система, която е създадена от шумерите и използвана от вавилонците.
Бройни системи
До момента разгледахме историята на бройните системи. Нека сега разгледаме какво представляват те и каква е тяхната роля в изчислител-ната техника.
Какво представляват бройните системи?
Бройните системи (numeral systems) са начин за представяне (запис-ване) на числата, чрез краен набор от графични знаци наречени цифри. Към тях трябва да се добавят и правила за представяне на числата. Символите, които се използват при представянето на числата в дадена бройна система, могат да се възприемат като нейна азбука.
По време на различните етапи от развитието на човечеството, различни бройни системи са придобивали известност. Трябва да се отбележи, че днес най-широко разпространение е получила арабската бройна система. Тя използва цифрите 0, 1, 2, 3, 4, 5, 6, 7, 8 и 9, като своя азбука. (Интересен е фактът, че изписването на арабските цифри в днешно време се различава от представените по-горе десет цифри, но въпреки това, те пак се отнасят за същата бройна система, т.е. десетичната).
Освен азбука, всяка бройна система има и основа. Основата е число, равно на броя различни цифри, използвани от системата за записване на
числата в нея. Например арабската бройна система е десетична, защото
има 10 цифри. За основа може да се избере произволно число, чиято
абсолютна стойност трябва да бъде различна от 0 и 1. Тя може да бъде и
реално или комплексно число със знак.
В практическо отношение, възниква въпросът: коя е най-добрата бройна
система, която трябва да използваме? За да си отговорим на този въпрос,
трябва да решим, как ще се представи по оптимален начин едно число
като записване (т.е. брой на цифрите в числото) и брой на цифрите, които
използва съответната бройна система, т.е. нейната основа. По математи-
чески път, може да се докаже, че най-доброто съотношение между дължи-
ната на записа и броя на използваните цифри, се постига при основа на
бройната система Неперовото число (e = 2,718281828), което е основата
на естествените логаритми. Да се работи в система с тази основа, е
изключително неудобно, защото това число не може да се представи като
отношение на две цели числа. Това ни дава основание да заключим, че
оптималната основа на бройната система е 2 или 3. Въпреки, че 3 е по-
близо до Неперовото число, то е неподходящо за техническа реализация.
Поради тази причина, двоичната бройна система, е единствената подхо-
дяща за практическа употреба и тя се използва в съвременните елек-
тронноизчислителни машини.</contents>
  </article>
  <article>
    <author>Светлин Наков</author>
    <title>Цикли</title>
    <year>2013</year>
    <month>11</month>
    <day>12</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\NakovAlgPic.jpg</image>
    <category>Въведение в програмирането със C#</category>
    <description>Какво е "цикъл"?</description>
    <contents>В програмирането често се налага многократно изпълнение на дадена последователност от операции. Цикъл (loop) е основна конструкция в програмирането, която позволява многократно изпълнение на даден фраг-мент сорс код. В зависимост от вида на цикъла, програмният код в него се повтаря или фиксиран брой пъти или докато е в сила дадено условие.
Цикъл, който никога не завършва, се нарича безкраен цикъл (infinite loop). Използването на безкраен цикъл рядко се налага, освен в случаи, когато някъде в тялото на цикъла се използва операторът break, за да бъде прекратено неговото изпълнение преждевременно. Ще разгледаме тази възможност по-късно, а сега нека разгледаме конструкциите за цикли в езика C#.
Конструкция за цикъл while
Един от най-простите и най-често използвани цикли е while.
while (условие)
{
     тяло на цикъла;
}</contents>
  </article>
  <article>
    <author>Светлин Наков</author>
    <title>Вход и изход от конзолата</title>
    <year>2013</year>
    <month>12</month>
    <day>5</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\NakovAlgPic.jpg</image>
    <category>Въведение в програмирането със C#</category>
    <description></description>
    <contents>Какво представлява конзолата?
Конзолата представлява прозорец на операционната система, през който потребителите могат да си взаимодействат със системните програми на операционната система или с други конзолни приложения. Взаимодей-ствието се състои във въвеждане на текст от стандартния вход (най-често клавиатурата) или извеждане на текст на стандартния изход (най-често на екрана на компютъра). Тези действия са известни още, като входно-изходни операции. Текстът, изписван на конзолата носи определена информация и представлява поредица от символи изпратени от една или няколко програми.
За всяко конзолно приложение операционната система свързва устройства за вход и изход. По подразбиране това са клавиатурата и екрана, но те могат да бъдат пренасочвани към файл или други устройства.
Комуникация между потребителя и програмата
Голяма част от програмите си комуникират по някакъв начин с потре-бителя. Това е необходимо, за да може потребителя да даде своите инструкции към тях. Съвременните начини за комуникация са много и различни: те могат да бъдат през графичен или уеб-базиран интерфейс, конзола или други. Както споменахме, едно от средствата за комуникация между програмите и потребителя е конзолата, но тя става все по-рядко използвана. Това е така, понеже съвременните средства за реализация на потребителски интерфейс са по-удобни и интуитивни за работа.
Кога да използваме конзолата?
В някои случаи, конзолата си остава незаменимо средство за комуникация с потребителя. Един от тези случаи е при писане на малки и прости програмки, където е необходимо вниманието да е насочено към кон-кретния проблем, който решаваме, а не към елегантно представяне на резултата на потребителя. Тогава се използва просто решение за въвеждане или извеждане на резултат, каквото е конзолният вход-изход. Друг случай на употреба е когато искаме да тестваме малка част от кода на по-голямо приложение. Поради простотата на работа на конзолното приложение, можем да изолираме тази част от кода лесно и удобно, без да се налага да преминаваме през сложен потребителски интерфейс и поредица от екрани, за да стигнем до желания код за тестване.
Стандартен вход-изход
Стандартният вход-изход известен още, като "Standard I/O" e системен входно-изходен механизъм създаден още от времето на Unix опера-ционните системи. За вход и изход се използват специални периферни устройства, чрез които може да се въвеждат и извеждат данни.
Когато програмата е в режим на приемане на информация и очаква действие от страна на потребителя, в конзолата започва да мига курсор, подсказващ, че системата очаква въвеждане на команда.
По-нататък ще видим как можем да пишем C# програми, които очакват въвеждане на входни данни от конзолата.
Печатане на конзолата
В повечето програмни езици отпечатването и четенето на информация от
конзолата е реализирано по различен начин, но повечето решения се
базират на концепцията за "стандартен вход" и "стандартен изход".
Стандартен вход и стандартен изход
Операционната система е длъжна да дефинира стандартни входно-
изходни механизми за взаимодействие с потребителя. При стартиране на
дадена конзолна програма, служебен код изпълняван в началото на
програмата е отговорен за отварянето (затварянето) на потоци, към
предоставените от операционната система механизми за вход-изход. Този
служебен код инициализира програмната абстракция за взаимодействие с
потребителя, заложена в съответния език за програмиране. По този начин
стартираното приложение може да чете наготово потребителски вход от
стандартния входен поток (в C# това е Console.In), може да записва
информация в стандартния изходен поток (в C# това е Console.Out) и
може да съобщава проблемни ситуации в стандартния поток за грешки (в
C# това е Console.Error).
Концепцията за потоците ще бъде подробно разгледана по-късно. Засега
ще се съсредоточим върху теоретичната основа, засягаща програмния
вход и изход в C#.
Вход от конзолата
Както в началото на темата обяснихме, най-подходяща за малки приложе-ния е конзолната комуникация, понеже е най-лесна за имплементиране. Стандартното входно устройство е тази част от операционната система, която контролира от къде програмата ще получи своите входни данни. По подразбиране "стандартното входно устройство" чете своя вход от драйвер "закачен" за клавиатурата. Това може да бъде променено и стандартният вход може да бъде пренасочен към друго място, например към файл, но това се прави рядко.
Всеки език за програмиране има механизъм за четене и писане в конзолата. Обектът, контролиращ стандартния входен поток в C#, е Console.In.
От конзолата можем да четем различни данни:
- текст;
- други типове, след "парсване" на текста.
Реално за четене рядко се използва стандартният входен поток Console.In директно. Класът Console предоставя два метода Console. Read() и Console.ReadLine(), които работят върху този поток и обикновено четенето от конзолата се осъществява чрез тях.
Четене чрез Console.ReadLine()
Най-голямо удобство при четене от конзолата предоставя методът Console.ReadLine(). Как работи той? При извикването му програмата преустановява работата си и чака за вход от конзолата. Потребителят въвежда някакъв стринг в конзолата и натиска клавишът [Enter]. В този момент конзолата разбира, че потребителят е свършил с въвеждането и прочита стринга. Методът Console.ReadLine() връща като резултат въведения от потребителя стринг. Сега може би е ясно, защо този метод има такова име.</contents>
  </article>
  <article>
    <author>Светлин Наков</author>
    <title>Методи</title>
    <year>2013</year>
    <month>12</month>
    <day>5</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\NakovAlgPic.jpg</image>
    <category>Въведение в програмирането със C#</category>
    <description>Подпрограмите в програмирането</description>
    <contents>Подпрограмите в програмирането
В ежедневието ни, при решаването на даден проблем, особено, ако е по-сложен, прилагаме принципа на древните римляни "разделяй и владей". Съгласно този принцип, проблемът, който трябва да решим, се разделя на множество по-малки подпроблеми. Самостоятелно разгледани, те са по-ясно дефинирани и по-лесно решими, в сравнение с търсенето на реше-ние на изходния проблем като едно цяло. Накрая, от решенията на всички подпроблеми, създаваме решението на цялостния проблем.
По същата аналогия, когато пишем дадена програма, целта ни е с нея да решим конкретна задача. За да го направим ефективно и да улесним работата си, прилагаме принципа "разделяй и владей". Разбиваме поста-вената ни задача на подзадачи, разработваме решения на тези подзадачи и накрая ги "сглобяваме" в една програма. Решенията на тези подзадачи наричаме подпрограми (subroutines).
В някои езици за програмиране подпрограмите могат да се срещнат под наименованията функции (functions) или процедури (procedures). В C#, те се наричат методи (methods).
Какво е "метод"?
Метод (method) е съставна част от програмата, която решава даден проблем, може да приема параметри и да връща стойност.
В методите се извършва цялата обработка на данни, която програмата трябва да направи, за да реши поставената задача. Методите съдържат логиката на програмата и те са мястото, където се извършва реалната работа. Затова можем да ги приемем като строителен блок на програмата. Съответно, имайки множество от простички блокчета – отделни методи, можем да създаваме големи програми, с които да решим по-сложни проблеми. Ето например как изглежда един метод за намиране лице на правоъгълник:
static double GetRectangleArea(double width, double height)
{
double area = width * height;
return area;
}
Защо да използваме методи?
Има много причини, които ни карат да използваме методи. Ще разгледаме някои от тях и с времето ще се убедите, че методите са нещо, без което не можем, ако искаме да програмираме сериозно.
По-добро структуриране и по-добра четимост
При създаването на една програма, е добра практика да използваме методи, за да я направим добре структурирана и лесно четима не само за нас, но и за други хора.
Довод за това е, че за времето, през което съществува една програма, средно само 20% от усилията, които се заделят за нея, се състоят в създаване и тестване на кода. Останалата част е за поддръжка и добавяне на нови функционалности към началната версия. В повечето случаи, след като веднъж кодът е написан, той не се поддържа и модифицира само от създателя му, но и от други програмисти. Затова е важно той да е добре структуриран и лесно четим.
Избягване на повторението на код
Друга много важна причина, заради която е добре да използваме методи е, че по този начин избягваме повторението на код. Това е пряко свързано с концепцията за преизползване на кода.
Преизползване на кода
Добър стил на програмиране е, когато използваме даден фрагмент програмен код повече от един или два пъти в програмата си, да го дефинираме като отделен метод, за да можем да го изпълняваме многократно. По този начин освен, че избягваме повторението на код, програмата ни става по-четима и по-добре структурирана.
Повтарящият се код е вреден и доста опасен, защото силно затруднява поддръжката на програмата и води до грешки. При промяната на повтарящ се код често пъти програмистът прави промени само на едно място, а останалите повторения на кода си остават същите. Така напри-мер, ако е намерен дефект във фрагмент от 50 реда код, който се повтаря на 10 места в програмата, за да се поправи дефектът, трябва на всичките тези 10 места да се преправи кода по един и същ начин. Това най-често не се случва поради невнимание и програмистът обикновено поправя само някои от повтарящите се дефекти, но не всички. Например в нашия случай е възможно програмистът да поправи проблема на 8 от 10-те места, в които се повтаря некоректния код и това в крайна сметка ще доведе до некоректно поведение на програмата в някои случаи, което е трудно да се установи и поправи.
Деклариране, имплементация и извикване на собствен метод
Преди да продължим по-нататък, ще направим разграничение между три действия свързани със съществуването на един
Деклариране на метод наричаме регистрирането на метода в програ-мата, за да бъде разпознаван в останалата част от нея.
Имплементация (създаване) на метода, е реалното написване на кода, който решава конкретната задача, която методът решава. Този код се съдържа в самия метод и реализира неговата логика.
Извикване е процесът на стартиране на изпълнението, на вече деклари-рания и създаден метод, от друго място на програмата, където трябва да се реши проблемът, за който е създаден извикваният метод.
Деклариране на собствен метод
Преди да се запознаем как можем да декларираме метод, трябва да знаем къде е позволено да го направим.
Къде е позволено да декларираме метод
Въпреки, че формално все още не сме запознати как се декларира клас, от примерите, които сме разглеждали до сега в предходните глави, знаем, че всеки клас има отваряща и затваряща фигурни скоби – "{" и "}", между които пишем програмния код. Повече подробности за това, ще научим в главата "Дефиниране на класове", но го споменаваме тук, тъй като един метод може да съществува само ако е деклариран между отварящата и затварящата скоби на даден клас – "{" и "}". Допълнително изискване е методът, трябва да бъде деклариран извън имплементацията на друг метод</contents>
  </article>
  <article>
    <author>Светлин Наков</author>
    <title>Рекурсия</title>
    <year>2013</year>
    <month>12</month>
    <day>20</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\NakovAlgPic.jpg</image>
    <category>Въведение в програмирането със C#</category>
    <description>Какво е рекурсия?</description>
    <contents>Какво е рекурсия?
Един обект наричаме рекурсивен, ако съдържа себе си или е дефиниран чрез себе си.
Рекурсия е програмна техника, при която даден метод извиква сам себе си при решаването на определен проблем. Такива методи наричаме рекурсивни.
Рекурсията е програмна техника, чиято правилна употреба води до еле-гантни решения на определени проблеми. Понякога нейното използване може да опрости значително кода и да подобри четимостта му.
Пряка и косвена рекурсия
Когато в тялото на метод се извършва извикване на същия метод, казваме, че методът е пряко рекурсивен.
Ако метод A се обръща към метод B, B към C, а С отново към А, казваме, че методът А, както и методите В и C са непряко (косвено) рекурсивни или взаимно-рекурсивни.
Веригата от извиквания при косвената рекурсия може да съдържа множество методи, както и разклонения, т.е. при наличие на едно условие да се извиква един метод, а при различно условие да се извиква друг.
Дъно на рекурсията
Реализирайки рекурсия, трябва да сме сигурни, че след краен брой стъпки ще получим конкретен резултат. Затова трябва да имаме един или няколко случаи, чието решение можем да намерим директно, без рекур-сивно извикване. Тези случаи наричаме дъно на рекурсията.
В примера с числата на Фибоначи, дъното на рекурсията е случаят, когато n e по-малко или равно на 2. При него можем директно да върнем резул-тат, без да извършваме рекурсивни извиквания, тъй като по дефиниция първите два члена на редицата на Фибоначи са равни на 1.
Ако даден рекурсивен метод няма дъно на рекурсията, тя ще стане безкрайна и резултатът ще е StackOverflowException.
Създаване на рекурсивни методи
Когато създаваме рекурсивни методи, трябва разбием задачата, която решаваме, на подзадачи, за чието решение можем да използваме същия алгоритъм (рекурсивно).
Комбинирането на решенията на всички подзадачи, трябва да води до решение на изходната задача.
При всяко рекурсивно извикване, проблемната област трябва да се огра-ничава така, че в даден момент да бъде достигнато дъното на рекурсията, т.е. разбиването на всяка от подзадачите трябва да води рано или късно до дъното на рекурсията.
Рекурсивно изчисляване на факториел
Използването на рекурсия ще илюстрираме с един класически пример – рекурсивно изчисляване на факториел.
Факториел от n (записва се n!) е произведението на естествените числа от 1 до n, като по дефиниция 0! = 1.
Рекурентна дефиниция
При създаването на нашето решение, много по-удобно е да използваме съответната рекурентна дефиниция на факториел:
n! = 1, при n = 0
n! = n.(n-1)! за n&gt;0
Намиране на рекурентна зависимост
Наличието на рекурентна зависимост не винаги е очевидно. Понякога се налага сами да я открием. В нашия случай можем да направим това, анализирайки проблема и пресмятайки стойностите на факториел за първите няколко естествени числа.
0! = 1
1! = 1 = 1.1 = 1.0!
2! = 2.1 = 2.1!
3! = 3.2.1 = 3.2!
4! = 4.3.2.1 = 4.3!
5! = 5.4.3.2.1 = 5.4!
Реализация на алгоритъма
Дъното на нашата рекурсия е най-простият случай n = 0, при който стойността на факториел е 1.
В останалите случаи, решаваме задачата за n-1 и умножаваме получения резултат по n. Така след краен брой стъпки, със сигурност ще достигнем дъното на рекурсията, понеже между 0 и n има краен брой естествени числа.
След като имаме налице тези ключови условия, можем да реализираме метод изчисляващ факториел:
static decimal Factorial(int n)
{
// The bottom of the recursion
if (n == 0)
{
return 1;
}
// Recursive call: the method calls itself
else
{
return n * Factorial(n - 1);
}
}</contents>
  </article>
  <article>
    <author>Преслав Наков</author>
    <title>Изкуствен интелект</title>
    <year>2013</year>
    <month>10</month>
    <day>20</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\ProgrAlgPic.jpg</image>
    <category>Програмиране+=Алгоритми;</category>
    <description>Компютърна информатика, алгоритми и програмиране</description>
    <contents>Изкуственият интелект е добре известна материя, но спорове за това какво обхваща тя и какво точно представлява не липсват и днес. Въпросът в каква степен “интелектът” е свързан с компютърния потенциал е основен и в момента доминират главно две направления, които могат да бъдат обобщени накратко така:
 Силно направление: Задачата на изкуствения интелект е да изследва, разбира и моделира процеса на разумно мислене.
 Слабо направление: Задачата на изкуствения интелект е да моделира системи, в които определени действия могат да бъдат изпълнявани със същата успеваемост, както ако се изпълняват от човека.
Границата между двете направления е условна и теоретически всяка разглеждана задача и всеки получен резултат може да се интерпретира от двете гледни точки: силна (доколко точно начинът на работа на системата моделира мисленето и действията на човека върху същата задача) и слабо (доколко успешна е машината). Същественото различие е, че силното направление изисква машината да работи и мисли така, както се предполага, че го прави човекът, докато слабото не се интересува от начина, а от резултата. В частност при слабото направление е напълно допустимо и дори силно желателно машината да се справя по-добре от човека, ако това е възможно, докато силното направление не толерира това: ако човекът често прави определен вид логическа грешка в разсъжденията си, машината също трябва да я прави.
Силното направление се занимава главно с проблеми като разбиране и интерпретиране на естествените езици, както и философски въпроси като: “Какво да разбираме под интелигентна машина?” В допълнение, съществува връзка с логическото мислене, когнитивната наука, психо-логията, лингвистика и др.
При слабото направление засега е постигнат доста по-сериозен напредък. Един конкретен успешен пример в това отношение са експертните системи. Най-общо, те разглеждат въпроса за разпространение на знания и опит на специалисти в определена тясно специализирана област. Съществуват редица успешни реализации на експертни системи за търсене на (ценни) суровинни находища, медицински системи за диагностика на определени заболявания, системи за помощ при интерпретиране и прилагане на закона и други.
Като цяло идеите и на двата “противоположни лагера” заемат централно място в изследва-нията на съвременната компютърна информатика и пред тях непрекъснато се откриват нови въз-можности за разширение и бъдещо развитие.
Следващата тема е тясно свързана с някои вече</contents>
  </article>
  <article>
    <author>Преслав Наков</author>
    <title>Определяне на сложност на алгоритъм</title>
    <year>2013</year>
    <month>10</month>
    <day>21</day>
    <image>C:\Users\Stanev\Documents\SVN\HMTDPTeamLibraryProject\bin\Debug\..\..\Images\ProgrAlgPic.jpg</image>
    <category>Програмиране+=Алгоритми;</category>
    <description>Въведение в алгоритмите</description>
    <contents>Ще разгледаме някои основни свойства, с помощта на които ще можем да определяме сложност на алгоритъм по дадена негова реализация на Си. Ще използваме T(код) за означаване сложността както на отделна операция, така и на програмен фрагмент. Понякога, когато кодът се подразбира, ще използваме означението T(n), за да покажем изрично, че сложността е функция на променливата n. Ще работим изключително с нотацията O(...). Оставяме на читателя да съобрази къде О(...) може да се замени с по-точната оценка (...).
- Елементарна операция
Сложността на елементарна операция е константа, т.е. O(1).
Не е лесно да се дефинира какво е елементарна операция. При различни обстоятелства ще си позволяваме да променяме дефиницията. По принцип елементарна операция е такава, която се изпълнява за константно време, независещо от размера на обработваните данни. Елементарни операции в общия случай са например присвояването, събирането, умножението и др. Когато обаче работим със стоцифрени числа, едва ли е добре да приемем умножението за елементарна операция. Не е добре да приемаме за елементарни операции тригонометричните функции (синус, косинус и др.), експонентата, логаритъмът и други библиотечни функции в Си, които се пресмятат с редове. Обръщението към такава функция предизвиква цикъл за пресмятане на търсената стойност. От друга страна тези редове се пресмятат до достигането на определена точност, като броят на итерациите за пресмятане на търсената стойност може да се разглеждат като независещи от n. Дали и какво влияние оказва това на оценката на сложността на алгоритъма зависи от случая и следва да се разглежда конкретно.</contents>
  </article>
</articles>